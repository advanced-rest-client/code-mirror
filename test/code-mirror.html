<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <title>code-mirror tests</title>

  <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
  <script src="../node_modules/mocha/mocha.js"></script>
  <script src="../node_modules/chai/chai.js"></script>
  <script src="../node_modules/wct-mocha/wct-mocha.js"></script>
  <script src="../node_modules/sinon/pkg/sinon.js"></script>

  <!-- CodeMirror imports -->
  <script src="../../../jsonlint/lib/jsonlint.js"></script>
  <script src="../../../codemirror/lib/codemirror.js"></script>
  <script src="../../../codemirror/addon/mode/loadmode.js"></script>
  <script src="../../../codemirror/mode/meta.js"></script>
  <script src="../../../codemirror/mode/javascript/javascript.js"></script>
  <script src="../../../codemirror/mode/xml/xml.js"></script>
  <script src="../../../codemirror/mode/htmlmixed/htmlmixed.js"></script>

  <script>
  /* global CodeMirror */
  CodeMirror.modeURL = '../../../codemirror/mode/%N/%N.js';
  </script>
</head>

<body>
  <test-fixture id="Basic">
    <template>
      <code-mirror mode="javascript"></code-mirror>
    </template>
  </test-fixture>

  <test-fixture id="Required">
    <template>
      <code-mirror required mode="javascript"></code-mirror>
    </template>
  </test-fixture>

  <test-fixture id="KeyMap">
    <template>
      <code-mirror key-map="emacsy" mode="javascript"></code-mirror>
    </template>
  </test-fixture>

  <test-fixture id="ModeMime">
    <template>
      <code-mirror mode="application/xml"></code-mirror>
    </template>
  </test-fixture>

  <test-fixture id="ModeExt">
    <template>
      <code-mirror mode="file.xml"></code-mirror>
    </template>
  </test-fixture>

  <script type="module">
  import '../code-mirror.js';
  import {afterNextRender} from '@polymer/polymer/lib/utils/render-status.js';
  suite('<code-mirror> basic', () => {
    test('change mode', function() {
      const editor = fixture('Basic');
      editor.mode = 'markdown';
      assert.equal(editor.editor.options.mode, 'markdown');
    });

    test('Dispatches value-changed event', function() {
      const editor = fixture('Basic');
      const word = 'TEST';
      const spy = sinon.spy();
      editor.addEventListener('value-changed', spy);
      editor.value = word;
      assert.equal(spy.args[0][0].detail.value, word);
    });

    test('The before-change event fired', function() {
      const editor = fixture('Basic');
      const word = 'TEST';
      const spy = sinon.spy();
      editor.addEventListener('before-change', spy);
      editor.value = word;
      assert.ok(spy.args[0][0].detail.change);
    });

    test('Canceled before-change event don\'t set value', function(done) {
      const editor = fixture('Basic');
      const word = 'TEST';
      const clb = function(e) {
        e.detail.change.cancel();
        // Event must to finish propagating, scheduliting test to next microtask.
        setTimeout(function() {
          assert.equal(editor.value, editor.editor.getValue());
          done();
        }, 0);
      };
      editor.addEventListener('before-change', clb);
      editor.value = word;
    });

    test('Sets keyMap', (done) => {
      const element = fixture('KeyMap');
      afterNextRender(element, () => {
        assert.equal(element.editor.getOption('keyMap'), 'emacsy');
        done();
      });
    });

    test('Loads mode by mime type', () => {
      const element = fixture('ModeMime');
      afterNextRender(element, () => {
        assert.equal(element.editor.getOption('mode'), 'xml');
        done();
      });
    });

    test('Loads mode by extension', () => {
      const element = fixture('ModeExt');
      afterNextRender(element, () => {
        assert.equal(element.editor.getOption('mode'), 'xml');
        done();
      });
    });
  });

  suite('_setPendingOptions()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Does nothing when no options', () => {
      element._pendingOptions = undefined;
      element._setPendingOptions();
      // test coverage
    });

    test('Calls setOption()', () => {
      element._pendingOptions = [{
        option: 'readOnly',
        value: true
      }];
      const spy = sinon.spy(element, 'setOption');
      element._setPendingOptions();
      assert.equal(spy.args[0][0], 'readOnly');
      assert.isTrue(spy.args[0][1]);
    });

    test('Clears _pendingOptions()', () => {
      element._pendingOptions = [{
        option: 'readOnly',
        value: true
      }];
      element._setPendingOptions();
      assert.isUndefined(element._pendingOptions);
    });

    test('Calls callback function', () => {
      element._pendingOptions = [{
        option: 'readOnly',
        value: true,
        post: () => {}
      }];
      const spy = sinon.spy(element._pendingOptions[0], 'post');
      element._setPendingOptions();
      assert.isTrue(spy.called);
    });
  });

  suite('refresh()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Calls refresh on the editor', () => {
      const spy = sinon.spy(element.editor, 'refresh');
      element.refresh();
      assert.isTrue(spy.called);
    });

    test('Does nothing when no editor', () => {
      element._setEditor(undefined);
      element.refresh();
      // coverage, no error
    });
  });

  suite('focus()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Calls refresh on the editor', () => {
      const spy = sinon.spy(element.editor, 'focus');
      element.focus();
      assert.isTrue(spy.called);
    });

    test('Does nothing when no editor', () => {
      element._setEditor(undefined);
      element.focus();
      // coverage, no error
    });
  });

  suite('_getValidity()', () => {
    let element;
    setup(() => {
      element = fixture('Required');
    });

    test('Resturns false when no value and required', () => {
      element.value = '';
      const result = element._getValidity();
      assert.isFalse(result);
    });

    test('Resturns true when value and required', () => {
      element.value = 'test';
      const result = element._getValidity();
      assert.isTrue(result);
    });

    test('Resturns true when no value and not required', () => {
      element.required = false;
      const result = element._getValidity();
      assert.isTrue(result);
    });
  });
  </script>
</body>

</html>
